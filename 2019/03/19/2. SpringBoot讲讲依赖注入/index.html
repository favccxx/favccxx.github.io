<!DOCTYPE HTML>
<html lang>
<head><meta name="generator" content="Hexo 3.8.0">
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="Hexo">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

    <meta name="keywords" content>


    <meta name="description" content="Spring的发展史
Spring的发展经过三个阶段
I. Spring 1.0 时代
基于XML配置的Java Bean，将XML
Ⅱ. Spring 2.0 注解配置
JDK 1.5引入注解...">



<meta name="robots" content="all">
<meta name="google" content="all">
<meta name="googlebot" content="all">
<meta name="verify" content="all">

    <!--Title-->


<title>Hexo</title>


    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">


    <link rel="icon" href="/favicon.ico">

    



<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">




    
	<div class="hide">
		<script type="text/javascript">
			var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
		</script>
	</div>






    

</head>

</html>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->

<body>
    <header class="main-header" style="background-image:url(http://snippet.shenliyang.com/img/banner.jpg)">
    <div class="main-header-box">
        <a class="header-avatar" href="/" title="John Doe">
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
        	<!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
                 <img src="/img/branding.png" alt="Snippet 博客主题" class="img-responsive center-block">
            
    	</div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                    <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">Hexo</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                            <li role="presentation" class="text-center">
                                <a href="/"><i class="fa "></i>Home</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/architecture/"><i class="fa "></i>架构设计</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/front/"><i class="fa "></i>前端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/java/"><i class="fa "></i>后端</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/categories/tool/"><i class="fa "></i>工具</a>
                            </li>
                        
                            <li role="presentation" class="text-center">
                                <a href="/archives/"><i class="fa "></i>时间轴</a>
                            </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id>
            
	            NO Title!
            
        </h1>
        <div class="post-meta">
    
        <span class="categories-meta fa-wrap">
            <i class="fa fa-folder-open-o"></i>
            
        </span>
    

    
        <span class="fa-wrap">
            <i class="fa fa-tags"></i>
            <span class="tags-meta">
                
            </span>
        </span>
    

    
        
        <span class="fa-wrap">
            <i class="fa fa-clock-o"></i>
            <span class="date-meta">2019/03/19</span>
        </span>
        
    
</div>
            
            
    </div>
    
    <div class="post-body post-content">
        <p>Spring的发展史</p>
<p>Spring的发展经过三个阶段</p>
<p>I. Spring 1.0 时代</p>
<p>基于XML配置的Java Bean，将XML</p>
<p>Ⅱ. Spring 2.0 注解配置</p>
<p>JDK 1.5引入注解  </p>
<p>三. Spring 3.0 Java配置</p>
<p>Spring 4.x 和 Spring boot都推荐使用JAVA配置来使用Java Bean,Java 配置通过@Configuration和@Bean来实现。</p>
<p>@Configuration 相当于声明一个xml配置文件</p>
<p>@Bean，注解作用在方法上，返回值为Bean对象。使用@Bean可以代替包扫描。</p>
<p>’‘’<br>@Configuration<br>@EnableSwagger2<br>public class SwaggerConfigure {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket createRestApi() &#123;</span><br><span class="line">	return new Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">			.apis(RequestHandlerSelectors.basePackage(&quot;com.favccxx.controller&quot;))</span><br><span class="line">			.paths(PathSelectors.any()).build();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>}<br>‘’‘</p>
<p>ApplicationContext 即是 Spring 程序的 IoC 容器, 该容器负责创建 Bean，现在Spring使用AutowireCapableBeanFactory 自动装配Bean。</p>
<p>public interface ApplicationContext extends EnvironmentCapable, ListableBeanFactory, HierarchicalBeanFactory,<br>        MessageSource, ApplicationEventPublisher, ResourcePatternResolver {</p>
<p>​    AutowireCapableBeanFactory getAutowireCapableBeanFactory() throws IllegalStateException;</p>
<p>}</p>
<p>Spring容器有多种方式创建管理Bean，一种是基于Java配置（AnnotationConfigApplicationContext），另外一种是基于注解类。</p>
<p>Ⅰ. AnnotationConfigApplicationContext容器读取一个或多个基于 java 的配置类, 只需在应用程序启动时，指定@scanner即可。实现方式如下：</p>
<p>‘’‘<br>public class AnnotationConfigApplicationContext extends GenericApplicationContext implements AnnotationConfigRegistry {</p>
<pre><code>private final AnnotatedBeanDefinitionReader reader;

private final ClassPathBeanDefinitionScanner scanner;


/**
 * Create a new AnnotationConfigApplicationContext that needs to be populated
 * through {@link #register} calls and then manually {@linkplain #refresh refreshed}.
 */
public AnnotationConfigApplicationContext() {
    this.reader = new AnnotatedBeanDefinitionReader(this);
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}

/**
 * Create a new AnnotationConfigApplicationContext with the given DefaultListableBeanFactory.
 * @param beanFactory the DefaultListableBeanFactory instance to use for this context
 */
public AnnotationConfigApplicationContext(DefaultListableBeanFactory beanFactory) {
    super(beanFactory);
    this.reader = new AnnotatedBeanDefinitionReader(this);
    this.scanner = new ClassPathBeanDefinitionScanner(this);
}

/**
 * Create a new AnnotationConfigApplicationContext, deriving bean definitions
 * from the given annotated classes and automatically refreshing the context.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link Configuration @Configuration} classes
 */
public AnnotationConfigApplicationContext(Class&lt;?&gt;... annotatedClasses) {
    this();
    register(annotatedClasses);
    refresh();
}

/**
 * Create a new AnnotationConfigApplicationContext, scanning for bean definitions
 * in the given packages and automatically refreshing the context.
 * @param basePackages the packages to check for annotated classes
 */
public AnnotationConfigApplicationContext(String... basePackages) {
    this();
    scan(basePackages);
    refresh();
}


/**
 * Propagates the given custom {@code Environment} to the underlying
 * {@link AnnotatedBeanDefinitionReader} and {@link ClassPathBeanDefinitionScanner}.
 */
@Override
public void setEnvironment(ConfigurableEnvironment environment) {
    super.setEnvironment(environment);
    this.reader.setEnvironment(environment);
    this.scanner.setEnvironment(environment);
}

/**
 * Provide a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}
 * and/or {@link ClassPathBeanDefinitionScanner}, if any.
 * &lt;p&gt;Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
 * &lt;p&gt;Any call to this method must occur prior to calls to {@link #register(Class...)}
 * and/or {@link #scan(String...)}.
 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
 */
public void setBeanNameGenerator(BeanNameGenerator beanNameGenerator) {
    this.reader.setBeanNameGenerator(beanNameGenerator);
    this.scanner.setBeanNameGenerator(beanNameGenerator);
    getBeanFactory().registerSingleton(
            AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
}

/**
 * Set the {@link ScopeMetadataResolver} to use for detected bean classes.
 * &lt;p&gt;The default is an {@link AnnotationScopeMetadataResolver}.
 * &lt;p&gt;Any call to this method must occur prior to calls to {@link #register(Class...)}
 * and/or {@link #scan(String...)}.
 */
public void setScopeMetadataResolver(ScopeMetadataResolver scopeMetadataResolver) {
    this.reader.setScopeMetadataResolver(scopeMetadataResolver);
    this.scanner.setScopeMetadataResolver(scopeMetadataResolver);
}


//---------------------------------------------------------------------
// Implementation of AnnotationConfigRegistry
//---------------------------------------------------------------------

/**
 * Register one or more annotated classes to be processed.
 * &lt;p&gt;Note that {@link #refresh()} must be called in order for the context
 * to fully process the new classes.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link Configuration @Configuration} classes
 * @see #scan(String...)
 * @see #refresh()
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
    Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
    this.reader.register(annotatedClasses);
}

/**
 * Perform a scan within the specified base packages.
 * &lt;p&gt;Note that {@link #refresh()} must be called in order for the context
 * to fully process the new classes.
 * @param basePackages the packages to check for annotated classes
 * @see #register(Class...)
 * @see #refresh()
 */
public void scan(String... basePackages) {
    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
    this.scanner.scan(basePackages);
}


//---------------------------------------------------------------------
// Convenient methods for registering individual beans
//---------------------------------------------------------------------

/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations, and optionally providing explicit constructor
 * arguments for consideration in the autowiring process.
 * &lt;p&gt;The bean name will be generated according to annotated component rules.
 * @param annotatedClass the class of the bean
 * @param constructorArguments argument values to be fed into Spring&apos;s
 * constructor resolution algorithm, resolving either all arguments or just
 * specific ones, with the rest to be resolved through regular autowiring
 * (may be {@code null} or empty)
 * @since 5.0
 */
public &lt;T&gt; void registerBean(Class&lt;T&gt; annotatedClass, Object... constructorArguments) {
    registerBean(null, annotatedClass, constructorArguments);
}

/**
 * Register a bean from the given bean class, deriving its metadata from
 * class-declared annotations, and optionally providing explicit constructor
 * arguments for consideration in the autowiring process.
 * @param beanName the name of the bean (may be {@code null})
 * @param annotatedClass the class of the bean
 * @param constructorArguments argument values to be fed into Spring&apos;s
 * constructor resolution algorithm, resolving either all arguments or just
 * specific ones, with the rest to be resolved through regular autowiring
 * (may be {@code null} or empty)
 * @since 5.0
 */
public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; annotatedClass, Object... constructorArguments) {
    this.reader.doRegisterBean(annotatedClass, null, beanName, null,
            bd -&gt; {
                for (Object arg : constructorArguments) {
                    bd.getConstructorArgumentValues().addGenericArgumentValue(arg);
                }
            });
}

@Override
public &lt;T&gt; void registerBean(@Nullable String beanName, Class&lt;T&gt; beanClass, @Nullable Supplier&lt;T&gt; supplier,
        BeanDefinitionCustomizer... customizers) {

    this.reader.doRegisterBean(beanClass, supplier, beanName, null, customizers);
}
</code></pre><p>}<br>’‘’</p>
<p>Ⅱ. AnnotationConfigWebApplicationContext: 专门为 web 应用准备的, 适用于注解方式</p>
<p>‘’’<br>public class AnnotationConfigWebApplicationContext extends AbstractRefreshableWebApplicationContext<br>        implements AnnotationConfigRegistry {</p>
<pre><code>@Nullable
private BeanNameGenerator beanNameGenerator;

@Nullable
private ScopeMetadataResolver scopeMetadataResolver;

private final Set&lt;Class&lt;?&gt;&gt; annotatedClasses = new LinkedHashSet&lt;&gt;();

private final Set&lt;String&gt; basePackages = new LinkedHashSet&lt;&gt;();


/**
 * Set a custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}
 * and/or {@link ClassPathBeanDefinitionScanner}.
 * &lt;p&gt;Default is {@link org.springframework.context.annotation.AnnotationBeanNameGenerator}.
 * @see AnnotatedBeanDefinitionReader#setBeanNameGenerator
 * @see ClassPathBeanDefinitionScanner#setBeanNameGenerator
 */
public void setBeanNameGenerator(@Nullable BeanNameGenerator beanNameGenerator) {
    this.beanNameGenerator = beanNameGenerator;
}

/**
 * Return the custom {@link BeanNameGenerator} for use with {@link AnnotatedBeanDefinitionReader}
 * and/or {@link ClassPathBeanDefinitionScanner}, if any.
 */
@Nullable
protected BeanNameGenerator getBeanNameGenerator() {
    return this.beanNameGenerator;
}

/**
 * Set a custom {@link ScopeMetadataResolver} for use with {@link AnnotatedBeanDefinitionReader}
 * and/or {@link ClassPathBeanDefinitionScanner}.
 * &lt;p&gt;Default is an {@link org.springframework.context.annotation.AnnotationScopeMetadataResolver}.
 * @see AnnotatedBeanDefinitionReader#setScopeMetadataResolver
 * @see ClassPathBeanDefinitionScanner#setScopeMetadataResolver
 */
public void setScopeMetadataResolver(@Nullable ScopeMetadataResolver scopeMetadataResolver) {
    this.scopeMetadataResolver = scopeMetadataResolver;
}

/**
 * Return the custom {@link ScopeMetadataResolver} for use with {@link AnnotatedBeanDefinitionReader}
 * and/or {@link ClassPathBeanDefinitionScanner}, if any.
 */
@Nullable
protected ScopeMetadataResolver getScopeMetadataResolver() {
    return this.scopeMetadataResolver;
}


/**
 * Register one or more annotated classes to be processed.
 * &lt;p&gt;Note that {@link #refresh()} must be called in order for the context
 * to fully process the new classes.
 * @param annotatedClasses one or more annotated classes,
 * e.g. {@link org.springframework.context.annotation.Configuration @Configuration} classes
 * @see #scan(String...)
 * @see #loadBeanDefinitions(DefaultListableBeanFactory)
 * @see #setConfigLocation(String)
 * @see #refresh()
 */
public void register(Class&lt;?&gt;... annotatedClasses) {
    Assert.notEmpty(annotatedClasses, &quot;At least one annotated class must be specified&quot;);
    Collections.addAll(this.annotatedClasses, annotatedClasses);
}

/**
 * Perform a scan within the specified base packages.
 * &lt;p&gt;Note that {@link #refresh()} must be called in order for the context
 * to fully process the new classes.
 * @param basePackages the packages to check for annotated classes
 * @see #loadBeanDefinitions(DefaultListableBeanFactory)
 * @see #register(Class...)
 * @see #setConfigLocation(String)
 * @see #refresh()
 */
public void scan(String... basePackages) {
    Assert.notEmpty(basePackages, &quot;At least one base package must be specified&quot;);
    Collections.addAll(this.basePackages, basePackages);
}


/**
 * Register a {@link org.springframework.beans.factory.config.BeanDefinition} for
 * any classes specified by {@link #register(Class...)} and scan any packages
 * specified by {@link #scan(String...)}.
 * &lt;p&gt;For any values specified by {@link #setConfigLocation(String)} or
 * {@link #setConfigLocations(String[])}, attempt first to load each location as a
 * class, registering a {@code BeanDefinition} if class loading is successful,
 * and if class loading fails (i.e. a {@code ClassNotFoundException} is raised),
 * assume the value is a package and attempt to scan it for annotated classes.
 * &lt;p&gt;Enables the default set of annotation configuration post processors, such that
 * {@code @Autowired}, {@code @Required}, and associated annotations can be used.
 * &lt;p&gt;Configuration class bean definitions are registered with generated bean
 * definition names unless the {@code value} attribute is provided to the stereotype
 * annotation.
 * @param beanFactory the bean factory to load bean definitions into
 * @see #register(Class...)
 * @see #scan(String...)
 * @see #setConfigLocation(String)
 * @see #setConfigLocations(String[])
 * @see AnnotatedBeanDefinitionReader
 * @see ClassPathBeanDefinitionScanner
 */
@Override
protected void loadBeanDefinitions(DefaultListableBeanFactory beanFactory) {
    AnnotatedBeanDefinitionReader reader = getAnnotatedBeanDefinitionReader(beanFactory);
    ClassPathBeanDefinitionScanner scanner = getClassPathBeanDefinitionScanner(beanFactory);

    BeanNameGenerator beanNameGenerator = getBeanNameGenerator();
    if (beanNameGenerator != null) {
        reader.setBeanNameGenerator(beanNameGenerator);
        scanner.setBeanNameGenerator(beanNameGenerator);
        beanFactory.registerSingleton(AnnotationConfigUtils.CONFIGURATION_BEAN_NAME_GENERATOR, beanNameGenerator);
    }

    ScopeMetadataResolver scopeMetadataResolver = getScopeMetadataResolver();
    if (scopeMetadataResolver != null) {
        reader.setScopeMetadataResolver(scopeMetadataResolver);
        scanner.setScopeMetadataResolver(scopeMetadataResolver);
    }

    if (!this.annotatedClasses.isEmpty()) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Registering annotated classes: [&quot; +
                    StringUtils.collectionToCommaDelimitedString(this.annotatedClasses) + &quot;]&quot;);
        }
        reader.register(ClassUtils.toClassArray(this.annotatedClasses));
    }

    if (!this.basePackages.isEmpty()) {
        if (logger.isDebugEnabled()) {
            logger.debug(&quot;Scanning base packages: [&quot; +
                    StringUtils.collectionToCommaDelimitedString(this.basePackages) + &quot;]&quot;);
        }
        scanner.scan(StringUtils.toStringArray(this.basePackages));
    }

    String[] configLocations = getConfigLocations();
    if (configLocations != null) {
        for (String configLocation : configLocations) {
            try {
                Class&lt;?&gt; clazz = ClassUtils.forName(configLocation, getClassLoader());
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Registering [&quot; + configLocation + &quot;]&quot;);
                }
                reader.register(clazz);
            }
            catch (ClassNotFoundException ex) {
                if (logger.isTraceEnabled()) {
                    logger.trace(&quot;Could not load class for config location [&quot; + configLocation +
                            &quot;] - trying package scan. &quot; + ex);
                }
                int count = scanner.scan(configLocation);
                if (count == 0 &amp;&amp; logger.isDebugEnabled()) {
                    logger.debug(&quot;No annotated classes found for specified class/package [&quot; + configLocation + &quot;]&quot;);
                }
            }
        }
    }
}


/**
 * Build an {@link AnnotatedBeanDefinitionReader} for the given bean factory.
 * &lt;p&gt;This should be pre-configured with the {@code Environment} (if desired)
 * but not with a {@code BeanNameGenerator} or {@code ScopeMetadataResolver} yet.
 * @param beanFactory the bean factory to load bean definitions into
 * @since 4.1.9
 * @see #getEnvironment()
 * @see #getBeanNameGenerator()
 * @see #getScopeMetadataResolver()
 */
protected AnnotatedBeanDefinitionReader getAnnotatedBeanDefinitionReader(DefaultListableBeanFactory beanFactory) {
    return new AnnotatedBeanDefinitionReader(beanFactory, getEnvironment());
}

/**
 * Build a {@link ClassPathBeanDefinitionScanner} for the given bean factory.
 * &lt;p&gt;This should be pre-configured with the {@code Environment} (if desired)
 * but not with a {@code BeanNameGenerator} or {@code ScopeMetadataResolver} yet.
 * @param beanFactory the bean factory to load bean definitions into
 * @since 4.1.9
 * @see #getEnvironment()
 * @see #getBeanNameGenerator()
 * @see #getScopeMetadataResolver()
 */
protected ClassPathBeanDefinitionScanner getClassPathBeanDefinitionScanner(DefaultListableBeanFactory beanFactory) {
    return new ClassPathBeanDefinitionScanner(beanFactory, true, getEnvironment());
}
</code></pre><p>}</p>
<p>‘’’</p>
<p>类定义时通过@Service, @Controller, @Repository, @Component 声明为 Spring Bean</p>
<p>@Component, 没有明确的角色</p>
<p>@Service, 用于业务服务层<br>@Controller, 用于展现层<br>@Repository, 用于 数据访问 层</p>
<p>注入Bean 注解，常用的有以下三种，虽然功能都一样，但大部分用户习惯使用@Autowired进行Bean注入。</p>
<p>@Autowired， Spring提供的注解</p>
<p>@Inject， JSR-330 提供的注解</p>
<p>@Resource， JSR-250提供的注解</p>
<p>以上说明在SpringBoot开发的项目中基本上会使用上面所说的全部内容，故不再给出示例代码。</p>

    </div>
    
    <div class="post-footer">
        <div>
            
                转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Snippet</a>
            
        </div>
        <div>
            
        </div>
    </div>
</article>

<div class="article-nav prev-next-wrap clearfix">
    
        <a href="/2019/03/19/3. SpringBoot AOP/" class="pre-post btn btn-default" title>
            <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
            <span class="hidden-xs"></span>
        </a>
    
    
        <a href="/2019/03/18/Spring Boot缓存/" class="next-post btn btn-default" title>
            <span class="hidden-lg">下一篇</span>
            <span class="hidden-xs"></span><i class="fa fa-angle-right fa-fw"></i>
        </a>
    
</div>


    <div id="comments">
        
	
    <div id="vcomments" class="valine"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>

    <script>
        new Valine({
            av: AV,
            el: '#vcomments',
            appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
            appKey: 'erIpQac4azoCmgfBB7Dl9maa',
            placeholder: '说点什么吧',
            notify: false,
            verify: false,
            avatar: 'mm',
            meta: 'nick,mail'.split(','),
            pageSize: '10',
            path: window.location.pathname,
            lang: ''.toLowerCase()
        })
    </script>


    </div>





                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">Table of Contents</h3>
        
            <p>暂无目录</p>
        
    </div>
</aside>

                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>

<a id="back-to-top" class="icon-btn hide">
	<i class="fa fa-chevron-up"></i>
</a>




    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>

            </div>
            <div class="col-sm-12">
                <span>Copyright &copy; 2017
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>







<script src="/js/app.js?rev=@@hash"></script>

</body>
</html>